<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>사과 연결 10 (Line Fix)</title>
    <style>
        :root {
            --bg-grad-start: #c3e6cb;
            --bg-grad-end: #a8d5ba;
            --primary-color: #00796b;
            --accent-color: #d32f2f;
            --text-color: #004d40;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, var(--bg-grad-start) 0%, var(--bg-grad-end) 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #main-scaler {
            transform-origin: center center;
            transition: transform 0.2s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: fit-content; 
        }

        #ui-header {
            width: 100%;
            height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .status-group {
            display: flex;
            gap: 20px;
            font-weight: bold;
            font-size: 18px;
            color: var(--text-color);
            align-items: center;
        }

        .status-item span {
            color: var(--accent-color);
            font-size: 24px;
            font-weight: 800;
            margin-left: 8px;
        }

        #reset-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--primary-color);
            transition: transform 0.3s;
            padding: 0;
            display: flex;
            align-items: center;
            opacity: 0.8;
        }
        #reset-btn:hover { transform: rotate(180deg); opacity: 1; }

        #gameBoard {
            background: #e8f5e9;
            /* 패딩 15px 중요: JS 좌표 계산에서 이 값을 사용함 */
            padding: 15px; 
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            position: relative;
            display: block; /* Flex가 아닌 Block으로 변경하여 캔버스 절대위치 기준점 확보 */
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(20, 30px);
            grid-template-rows: repeat(12, 30px);
            gap: 2px;
            position: relative;
            z-index: 10;
        }

        .apple {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            z-index: 10;
            touch-action: manipulation; 
        }

        .apple-inner {
            width: 26px;
            height: 26px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #d32f2f);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: 900;
            color: white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            transition: transform 0.1s;
            pointer-events: none;
        }

        .apple-inner::before {
            content: ''; position: absolute;
            top: -4px; left: 50%; transform: translateX(-50%);
            width: 4px; height: 6px; background: #795548; border-radius: 2px;
        }
        .apple-inner::after {
            content: ''; position: absolute;
            top: -5px; right: 6px;
            width: 8px; height: 6px; background: #66bb6a;
            border-radius: 0 50% 50% 0; transform: rotate(-20deg);
        }

        .apple.selected .apple-inner {
            transform: scale(1.2);
            background: radial-gradient(circle at 30% 30%, #ffd54f, #ffb300);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.6);
        }

        /* 수정: 캔버스 위치와 크기 보정 */
        #canvas {
            position: absolute;
            top: 0; 
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20; /* 사과보다 위에 그려지도록 (원하면 5로 낮춰도 됨) */
        }

        .floating-text {
            position: absolute;
            color: #ff6b00;
            font-weight: 900;
            font-size: 24px;
            pointer-events: none;
            z-index: 50;
            text-shadow: 2px 2px 0px white;
            animation: floatUp 0.8s ease-out forwards;
            white-space: pre;
            text-align: center;
        }
        .combo-text { color: #d32f2f; font-size: 28px; }
        @keyframes floatUp { to { transform: translateY(-40px) scale(1.2); opacity: 0; } }

        .particle {
            position: absolute;
            width: 6px; height: 6px;
            background: #d32f2f;
            border-radius: 50%;
            pointer-events: none;
            z-index: 40;
            animation: explode 0.6s ease-out forwards;
        }
        @keyframes explode { to { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }

        #gameOver {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 200;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .modal-content {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            animation: popIn 0.3s; box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .restart-big-btn {
            background: #00796b; color: white; border: none;
            padding: 15px 40px; font-size: 20px; border-radius: 30px;
            cursor: pointer; font-weight: bold; margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,121,107,0.4);
        }
        #timer.warning { color: #d32f2f; animation: pulse 0.5s infinite; }
        @keyframes pulse { 50% { transform: scale(1.2); } }
    </style>
</head>
<body>

    <div id="main-scaler">
        <div id="ui-header">
            <div class="status-group">
                <div class="status-item">점수 <span id="score">0</span></div>
                <div class="status-item">시간 <span id="timer">60</span></div>
            </div>
            <button id="reset-btn" onclick="resetGame()" title="다시 시작">↻</button>
        </div>

        <div id="gameBoard">
            <!-- 수정: 캔버스 크기를 실제 패딩 포함 크기에 맞춰 넉넉하게 설정 (670x420) -->
            <canvas id="canvas" width="670" height="420"></canvas>
            <div id="grid"></div>
        </div>
    </div>
    
    <div id="gameOver">
        <div class="modal-content">
            <h1 style="margin:0; color:#d32f2f;">GAME OVER</h1>
            <div style="font-size:60px; color:#2e7d32; margin:20px 0; font-weight:bold;" id="finalScore">0</div>
            <button class="restart-big-btn" onclick="resetGame()">다시 도전!</button>
        </div>
    </div>

    <script>
        const ROWS = 12; 
        const COLS = 20;
        const TILE_SIZE = 30;
        const GAP = 2;
        const TIME_LIMIT = 60;
        
        let grid = [];
        let selectedTile = null;
        let score = 0;
        let timeLeft = TIME_LIMIT;
        let timerInterval = null;
        let gameActive = true;
        let lastMatchTime = 0;
        let comboCount = 0;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridElement = document.getElementById('grid');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const mainScaler = document.getElementById('main-scaler');

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            try {
                if (audioContext.state === 'suspended') audioContext.resume();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                const now = audioContext.currentTime;

                if (type === 'select') {
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.1, now);
                    osc.stop(now + 0.1);
                } else if (type === 'success') {
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.stop(now + 0.3);
                } else if (type === 'combo') {
                    osc.frequency.setValueAtTime(1000 + (comboCount * 100), now);
                    osc.type = 'triangle';
                    gain.gain.setValueAtTime(0.15, now);
                    osc.stop(now + 0.3);
                } else if (type === 'error') {
                    osc.frequency.setValueAtTime(200, now);
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.1, now);
                    osc.stop(now + 0.15);
                } else if (type === 'tick') {
                    osc.frequency.setValueAtTime(1000, now);
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.05, now);
                    osc.stop(now + 0.05);
                }
                osc.start(now);
            } catch (e) { console.log(e); }
        }

        function resizeGame() {
            const windowW = window.innerWidth;
            const windowH = window.innerHeight;
            const baseW = 670; 
            const baseH = 500; 
            const scale = Math.min(windowW / baseW, windowH / baseH) * 0.95;
            mainScaler.style.transform = `scale(${scale})`;
        }
        window.addEventListener('resize', resizeGame);

        function initGame() {
            grid = [];
            for (let r = 0; r < ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
                        grid[r][c] = 0; 
                    } else {
                        grid[r][c] = Math.floor(Math.random() * 9) + 1;
                    }
                }
            }
            lastMatchTime = 0;
            comboCount = 0;
            renderGrid();
            resizeGame();
            startTimer();
        }

        function renderGrid() {
            gridElement.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== 0) {
                        const apple = document.createElement('div');
                        apple.className = 'apple';
                        apple.dataset.r = r;
                        apple.dataset.c = c;
                        apple.style.gridArea = `${r + 1} / ${c + 1} / span 1 / span 1`;
                        
                        const inner = document.createElement('div');
                        inner.className = 'apple-inner';
                        inner.textContent = grid[r][c];
                        apple.appendChild(inner);

                        apple.addEventListener('pointerdown', (e) => {
                            e.preventDefault(); 
                            handleTileClick(r, c);
                        });
                        gridElement.appendChild(apple);
                    }
                }
            }
        }

        function handleTileClick(r, c) {
            if (!gameActive) return;
            
            if (!selectedTile) {
                selectedTile = { r, c, val: grid[r][c] };
                highlightTile(r, c, true);
                playSound('select');
            } else {
                if (selectedTile.r === r && selectedTile.c === c) {
                    highlightTile(r, c, false);
                    selectedTile = null;
                    clearCanvas();
                    playSound('select');
                } else {
                    if (selectedTile.val + grid[r][c] === 10) {
                        const path = findPath(selectedTile.r, selectedTile.c, r, c);
                        if (path) {
                            handleMatch(selectedTile, { r, c, val: grid[r][c] }, path);
                        } else {
                            handleMismatch(r, c);
                        }
                    } else {
                        handleMismatch(r, c);
                    }
                }
            }
        }

        function handleMatch(tile1, tile2, path) {
            drawPath(path);
            const now = Date.now();
            if (now - lastMatchTime < 1500) comboCount++;
            else comboCount = 0;
            lastMatchTime = now;

            const baseScore = 10;
            const bonus = comboCount * 5;
            const totalAdd = baseScore + bonus;
            score += totalAdd;
            scoreElement.textContent = score;

            if (comboCount > 0) playSound('combo');
            else playSound('success');

            const targetEl = document.querySelector(`.apple[data-r="${tile2.r}"][data-c="${tile2.c}"]`);
            if (targetEl) {
                showFloatingText(targetEl, totalAdd, comboCount);
                createParticles(targetEl);
                const t1El = document.querySelector(`.apple[data-r="${tile1.r}"][data-c="${tile1.c}"]`);
                if(t1El) createParticles(t1El);
            }

            setTimeout(() => {
                removeTiles(tile1.r, tile1.c, tile2.r, tile2.c);
                selectedTile = null;
                clearCanvas();
            }, 200);
        }

        function handleMismatch(r, c) {
            playSound('error');
            if(selectedTile) highlightTile(selectedTile.r, selectedTile.c, false);
            selectedTile = { r, c, val: grid[r][c] };
            highlightTile(r, c, true);
            clearCanvas();
        }

        function showFloatingText(element, scoreAdd, combo) {
            const rect = element.getBoundingClientRect();
            const textEl = document.createElement('div');
            textEl.className = 'floating-text';
            if (combo > 0) {
                textEl.classList.add('combo-text');
                textEl.innerText = `+${scoreAdd}\nCOMBO ${combo}!`;
            } else {
                textEl.innerText = `+${scoreAdd}`;
            }
            textEl.style.left = (rect.left + window.scrollX) + 'px';
            textEl.style.top = (rect.top + window.scrollY - 20) + 'px';
            document.body.appendChild(textEl);
            setTimeout(() => textEl.remove(), 800);
        }

        function createParticles(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            for(let i=0; i<8; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = centerX + 'px';
                p.style.top = centerY + 'px';
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 20;
                p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 600);
            }
        }

        function highlightTile(r, c, highlight) {
            const tile = document.querySelector(`.apple[data-r="${r}"][data-c="${c}"]`);
            if (tile) {
                if (highlight) tile.classList.add('selected');
                else tile.classList.remove('selected');
            }
        }

        function removeTiles(r1, c1, r2, c2) {
            const t1 = document.querySelector(`.apple[data-r="${r1}"][data-c="${c1}"]`);
            const t2 = document.querySelector(`.apple[data-r="${r2}"][data-c="${c2}"]`);
            if(t1) t1.remove();
            if(t2) t2.remove();
            grid[r1][c1] = 0;
            grid[r2][c2] = 0;
        }

        function findPath(r1, c1, r2, c2) {
            if (r1 === r2 && isHorizontalClear(r1, Math.min(c1, c2), Math.max(c1, c2))) 
                return [{r: r1, c: c1}, {r: r2, c: c2}];
            if (c1 === c2 && isVerticalClear(c1, Math.min(r1, r2), Math.max(r1, r2))) 
                return [{r: r1, c: c1}, {r: r2, c: c2}];
            
            if (grid[r1][c2] === 0 && isHorizontalClear(r1, Math.min(c1, c2), Math.max(c1, c2)) && isVerticalClear(c2, Math.min(r1, r2), Math.max(r1, r2)))
                return [{r: r1, c: c1}, {r: r1, c: c2}, {r: r2, c: c2}];
            if (grid[r2][c1] === 0 && isVerticalClear(c1, Math.min(r1, r2), Math.max(r1, r2)) && isHorizontalClear(r2, Math.min(c1, c2), Math.max(c1, c2)))
                return [{r: r1, c: c1}, {r: r2, c: c1}, {r: r2, c: c2}];
            
            for (let c = 0; c < COLS; c++) {
                if (c === c1 || c === c2) continue;
                if (grid[r1][c] === 0 && grid[r2][c] === 0) {
                    if (isHorizontalClear(r1, Math.min(c1, c), Math.max(c1, c)) &&
                        isVerticalClear(c, Math.min(r1, r2), Math.max(r1, r2)) &&
                        isHorizontalClear(r2, Math.min(c, c2), Math.max(c, c2))) {
                        return [{r: r1, c: c1}, {r: r1, c}, {r: r2, c}, {r: r2, c: c2}];
                    }
                }
            }
            for (let r = 0; r < ROWS; r++) {
                if (r === r1 || r === r2) continue;
                if (grid[r][c1] === 0 && grid[r][c2] === 0) {
                    if (isVerticalClear(c1, Math.min(r1, r), Math.max(r1, r)) &&
                        isHorizontalClear(r, Math.min(c1, c2), Math.max(c1, c2)) &&
                        isVerticalClear(c2, Math.min(r, r2), Math.max(r, r2))) {
                        return [{r: r1, c: c1}, {r: r, c: c1}, {r: r, c: c2}, {r: r2, c: c2}];
                    }
                }
            }
            return null;
        }

        function isHorizontalClear(r, c1, c2) {
            for (let c = c1 + 1; c < c2; c++) if (grid[r][c] !== 0) return false;
            return true;
        }
        function isVerticalClear(c, r1, r2) {
            for (let r = r1 + 1; r < r2; r++) if (grid[r][c] !== 0) return false;
            return true;
        }

        // --- 핵심 수정: drawPath 좌표 계산 보정 ---
        function drawPath(path) {
            clearCanvas();
            ctx.strokeStyle = '#ffca28';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            
            // 상수는 CSS와 맞춰야 함
            const PADDING = 15;      // #gameBoard padding
            const CELL_FULL = 32;    // TILE_SIZE(30) + GAP(2)
            const HALF_TILE = 15;    // TILE_SIZE / 2
            
            for (let i = 0; i < path.length; i++) {
                // 공식: 패딩 + (인덱스 * 셀전체크기) + 반개크기(중앙정렬)
                let x = PADDING + (path[i].c * CELL_FULL) + HALF_TILE;
                let y = PADDING + (path[i].r * CELL_FULL) + HALF_TILE;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        
        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timeLeft = TIME_LIMIT;
            timerElement.textContent = timeLeft;
            timerElement.classList.remove('warning');
            timerInterval = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                if (timeLeft <= 10) {
                    timerElement.classList.add('warning');
                    playSound('tick');
                }
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            gameActive = false;
            clearInterval(timerInterval);
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'flex';
        }

        function resetGame() {
            gameActive = true;
            score = 0;
            scoreElement.textContent = score;
            gameOverElement.style.display = 'none';
            clearCanvas();
            initGame();
        }

        initGame();
    </script>
</body>
</html>
